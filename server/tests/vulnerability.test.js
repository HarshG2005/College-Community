import { jest } from '@jest/globals';
import request from 'supertest';
import express from 'express';

// Mock the auth middleware to bypass authentication
jest.unstable_mockModule('../middleware/auth.js', () => ({
    auth: (req, res, next) => {
        req.user = { _id: 'testuser' };
        next();
    },
    adminOnly: (req, res, next) => next()
}));

// Mock the StudyMaterial model
const mockFind = jest.fn().mockReturnThis();
const mockPopulate = jest.fn().mockReturnThis();
const mockSort = jest.fn().mockReturnThis();
const mockLimit = jest.fn().mockResolvedValue([]);

const mockStudyMaterial = {
    find: mockFind,
    populate: mockPopulate,
    sort: mockSort,
    limit: mockLimit
};

jest.unstable_mockModule('../models/StudyMaterial.js', () => ({
    default: mockStudyMaterial
}));

// Import the router dynamically after mocking
const { default: materialRoutes } = await import('../routes/materials.js');

const app = express();
app.use(express.json());
app.use('/api/materials', materialRoutes);

describe('GET /api/materials NoSQL Injection', () => {
    beforeEach(() => {
        jest.clearAllMocks();
        mockFind.mockReturnValue({
            populate: mockPopulate.mockReturnValue({
                sort: mockSort.mockReturnValue({
                    limit: mockLimit
                })
            })
        });
    });

    test('should pass string query normally', async () => {
        await request(app).get('/api/materials?subject=Math');

        expect(mockFind).toHaveBeenCalledWith(expect.objectContaining({
            subject: 'Math'
        }));
    });

    test('should prevent NoSQL injection object in subject query', async () => {
        // Attack: ?subject[$ne]=Math
        // If vulnerable, find is called with { subject: { '$ne': 'Math' } }
        // If fixed, find is called with { subject: '[object Object]' } or validation error

        const query = 'subject[$ne]=Math';
        await request(app).get(`/api/materials?${query}`);

        const calledArg = mockFind.mock.calls[0][0];
        console.log('Called with:', calledArg);

        // Assert that the subject is NOT an object with $ne
        if (typeof calledArg.subject === 'object') {
             // Vulnerable behavior
             expect(calledArg.subject).not.toHaveProperty('$ne');
        } else {
             // Secure behavior (sanitized to string)
             expect(typeof calledArg.subject).toBe('string');
        }
    });
});
